/**
 * run-scenario.mjs
 *
 * Executes a single self-test scenario by ID using the manifest generated by
 * scripts/generate-self-test.ts. Logs HTTP status and x-ratelimit headers.
 *
 * Env:
 *   - SCENARIO_ID (required)
 *   - TOKEN (required)
 *   - REPO (required, owner/name)
 */

import { readFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

const scenarioId = process.env.SCENARIO_ID || '';
const token = process.env.TOKEN || '';
const repo = process.env.REPO || '';

if (!scenarioId) {
  console.error('SCENARIO_ID is required.');
  process.exit(1);
}
if (!token) {
  console.error('TOKEN is required.');
  process.exit(1);
}
if (!repo) {
  console.error('REPO is required.');
  process.exit(1);
}

const manifestPath = join(dirname(fileURLToPath(import.meta.url)), 'self-test-manifest.json');
const manifest = JSON.parse(readFileSync(manifestPath, 'utf-8'));
const scenario = (manifest.scenarios || []).find((s) => s.id === scenarioId);

if (!scenario) {
  console.error(`Scenario not found: ${scenarioId}`);
  process.exit(1);
}

const headersToLog = [
  'x-ratelimit-limit',
  'x-ratelimit-remaining',
  'x-ratelimit-reset',
  'x-ratelimit-used',
  'x-ratelimit-resource',
];

function sleepSeconds(seconds) {
  return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
}

function resolveUrl(urlTemplate) {
  return urlTemplate.replaceAll('${REPO}', repo);
}

async function callEndpoint(endpoint, callNumber) {
  const url = resolveUrl(endpoint.url);
  const headers = {
    Authorization: `Bearer ${token}`,
    'User-Agent': 'github-api-usage-monitor-self-test',
  };

  if (endpoint.method === 'POST' && endpoint.contentType) {
    headers['Content-Type'] = endpoint.contentType;
  }

  const options = {
    method: endpoint.method,
    headers,
  };

  if (endpoint.method === 'POST') {
    options.body = endpoint.body || '';
  }

  try {
    const response = await fetch(url, options);
    console.log(`--- ${endpoint.bucket} call ${callNumber} ---`);
    console.log(`HTTP ${response.status}`);
    for (const headerName of headersToLog) {
      const value = response.headers.get(headerName);
      if (value) {
        console.log(`${headerName}: ${value}`);
      }
    }

    await response.arrayBuffer();

    if (!response.ok) {
      console.warn(`Non-2xx response for ${url}: ${response.status}`);
    }
  } catch (error) {
    const err = error instanceof Error ? error.message : String(error);
    console.warn(`Request failed for ${url}: ${err}`);
  }
}

async function runPacedPlan(plan) {
  const sequence = Array.isArray(plan.sequence) ? plan.sequence : [];
  if (sequence.length === 0 || plan.duration_s <= 0) {
    return;
  }

  const tickSeconds = Math.max(1, plan.tick_s || 1);
  const totalTicks = Math.max(1, Math.floor(plan.duration_s / tickSeconds));
  const bucketCounts = {};

  for (let i = 0; i < totalTicks; i += 1) {
    const endpoint = sequence[i % sequence.length];
    const bucket = endpoint.bucket || 'unknown';
    const count = (bucketCounts[bucket] || 0) + 1;
    bucketCounts[bucket] = count;
    await callEndpoint(endpoint, count);
    if (i < totalTicks - 1) {
      await sleepSeconds(tickSeconds);
    }
  }
}

async function runScenario() {
  const start = Date.now();

  if (scenario.paced_plan) {
    await runPacedPlan(scenario.paced_plan);
  } else {
    for (const endpointCall of scenario.endpoint_calls || []) {
      const calls = endpointCall.calls || 0;
      if (calls <= 0) continue;

      for (let i = 1; i <= calls; i += 1) {
        await callEndpoint(endpointCall.endpoint, i);
        if (scenario.inter_call_sleep_s > 0 && i < calls) {
          await sleepSeconds(scenario.inter_call_sleep_s);
        }
      }
    }
  }

  const elapsedSeconds = Math.floor((Date.now() - start) / 1000);
  const remainingSeconds = Math.max(10, scenario.poll_duration_s - elapsedSeconds);
  if (remainingSeconds > 0) {
    console.log(`Waiting for polls (${scenario.poll_duration_s}s total): sleep ${remainingSeconds}s`);
    await sleepSeconds(remainingSeconds);
  }
}

await runScenario();
